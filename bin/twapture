#!/usr/bin/env python
# Description: flexibly capture twitter streams using python logging
# Author: Jeff Terstriep <jterstriep@gmail.com>
# Date: 11/19/2015
# License:
"""
Provides a flexible tool for capturing tweets from Twitter's streaming API.
The stream can be filtered based on topics (keywords and phrases) and/or
location (bounding box). If no filters are specified the entire public
data stream is sampled.

Twapture uses Python's logging tool to record incoming tweets. By default,
a WatchedFileHandler is used so that an external process can manage file
rotation, but a TimedRotatingFileHandling can be specified to allow
twapture to self-manage its record files.

Twapture can be used as a command line tool to explore the twitter stream,
but it is primarily designed to work in concert with supervisord to provide
a robust, continuously running capture service.
"""

from __future__ import absolute_import, print_function
import os
import sys
import argparse
import json

import logging
import logging.handlers
logger = logging.getLogger('twapture')

from requests.packages import urllib3
urllib3.disable_warnings()

from tweepy import OAuthHandler
from tweepy import Stream

from twapture import MultiplexListener, StatusEncoder
from twapture.multiplex import pprint_tweets


def parse_interval(interval):
    "splits interval into numerical value and units"
    for i,c in enumerate(interval):
        if not c.isdigit():
            break;
    return (int(interval[:i]), interval[i:])


def parse_locations(locations):
    return [float(x.strip('[()]')) for x in locations.split(',')]


def config_watched_logger(logger, fname, level=logging.INFO):
    handler = logging.handlers.WatchedFileHandler(fname)
    handler.setLevel(level)
    formatter = logging.Formatter('%(asctime)-18s %(levelname)8s %(name)s '
                                  ': %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(level)


def config_watched_recorder(logger, fname, bufsize=100, level=logging.INFO):
    """Creates a logger with an in-memory handler that feeds a watched
       file handler.
    """
    handler = logging.handlers.WatchedFileHandler(fname)
    handler.setLevel(logging.INFO)
    memhandler = logging.handlers.MemoryHandler(bufsize, target=handler)
    memhandler.setLevel(logging.INFO)
    formatter = logging.Formatter('%(message)s')
    memhandler.setFormatter(formatter)
    logger.addHandler(memhandler)
    logger.setLevel(logging.INFO)


def config_timed_recorder(logger, fname, interval, bufsize=100, backupCount=0):
    """Creates a logger with an in-memory handler that acts as a buffer
       for a timed rotator file handler.
    """
    if interval in ('midnight', 'W0', 'W1', 'W2', 'W3', 'W4', 'W5', 'W6'):
        handler = logging.handlers.TimedRotatingFileHandler(fname, 
                when=interval, backupCount=backupCount)
    else:
        value, units = parse_interval(interval)
        handler = logging.handlers.TimedRotatingFileHandler(fname, 
                when=units, interval=value, backupCount=backupCount)

    memhandler = logging.handlers.MemoryHandler(bufsize, target=handler)
    formatter = logging.Formatter('%(message)s')
    memhandler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)


def export_shell(args):
    """writes the security values in a format useful for sourcing from shell"""

    print("export TWITTER_CONSUMER_KEY=%s" % args.ck)
    print("export TWITTER_CONSUMER_SECRET=%s" % args.cs)
    print("export TWITTER_ACCESS_TOKEN=%s" % args.at)
    print("export TWITTER_ACCESS_TOKEN_SECRET=%s" % args.ats)
    sys.exit(0)

def export_supervisord(args):
    """writes the security values in a format useful for supervisord config"""

    print('environment=TWITTER_CONSUMER_KEY="%s"=TWITTER_CONSUMER_SECRET'
          '="%s"=TWITTER_ACCESS_TOKEN="%s"=TWITTER_ACCESS_TOKEN_SECRET="%s"' \
          % (args.ck, args.cs, args.at, args.ats))
    sys.exit(0)


def validate(args):
    """check that necessary security keys are set
    """

    valid = True
    if not args.ck:
        logger.error('consumer key not set, use --consumer-key option')
        valid = False
    if not args.cs:
        logger.error('consumer secret not set, use --consumer-secret option')
        valid = False
    if not args.at:
        logger.error('access token not set, use --access-token option')
        valid = False
    if not args.ats:
        logger.error('access token secret not set, use '
                     '--access-token-secret option')
        valid = False

    return valid


def create_parser():

    parser = argparse.ArgumentParser(description=__doc__)

    parser.add_argument('recorder', 
           nargs='?', default='',
           help='filename where tweets will be written (default=stdout)')

    parser.add_argument('--locations',
           default='',
           help='bounding box (llx,lly,trx,try) to use as filter')

    parser.add_argument('--keywords',
           default='',
           help='comma separated list of keywords to use as filter')

    parser.add_argument('--log-stats',
           default=False, action='store_true',
           help='print collection statistics to log')

    parser.add_argument('--ck', '--consumer-key',
           default=os.environ.get('TWITTER_CONSUMER_KEY', ''),
           help='Twitter consumer key (default=$TWITTER_CONSUMER_KEY)')

    parser.add_argument('--cs', '--consumer-secret',
           default=os.environ.get('TWITTER_CONSUMER_SECRET', ''),
           help='Twitter consumer key (default=$TWITTER_CONSUMER_SECRET)')

    parser.add_argument('--at', '--access-token',
           default=os.environ.get('TWITTER_ACCESS_TOKEN', ''),
           help='Twitter access token (default=$TWITTER_CONSUMER_KEY)')

    parser.add_argument('--ats', '--access-token-secret',
           default=os.environ.get('TWITTER_ACCESS_TOKEN_SECRET', ''),
           help='Twitter access token secret')

    parser.add_argument('--trf', '--timed-rotating-file', 
           default='', metavar='INTERVAL',
           help='rotate the recorder file at fixed interval. Example: '
                'midnight or Nunit where N is interval and unit is '
                'single character d=day,h=hour, etc. If timed-rotating-file '
                'is not specified, a watched file is used.')

    
    parser.add_argument('--bs', '--buffer-size',
           default=100, metavar='RECORDS', type=int,
           help='buffer size in RECORDS (default=100)')

    parser.add_argument('--slf', '--system-log-file',
           default='twapture.log',
           help='the normal log file')

    parser.add_argument('--export-shell', dest='export_shell',
           default=False, action='store_true',
           help='export security values in shell format and exit')

    parser.add_argument('--export-supervisord', dest='export_supervisord',
           default=False, action='store_true',
           help='export security values in supervisord.conf format and exit')

    return parser


def main():

    parser = create_parser()
    args = parser.parse_args()

    # setup the error logger (logger is a global variable)
    config_watched_logger(logger, args.slf)

    # ensure that logger is configured prior to calling validate
    if not validate(args):
        parser.print_usage()
        sys.exit(1)

    # dumps the security tokens in convenient formats
    if args.export_shell:
        export_shell(args)
    if args.export_supervisord:
        export_supervisord(args)

    # create the twitter stream listener 
    auth = OAuthHandler(args.ck, args.cs)
    auth.set_access_token(args.at, args.ats)

    # create the tweet recorder, set the handlers
    if args.recorder:
        recorder = logging.getLogger(u'tweet_recorder')
        if args.trf:
            config_timed_recorder(recorder, args.recorder, args.trf,
                    bufsize=args.bs)
        else:
            config_watched_recorder(recorder, args.recorder, 
                    bufsize=args.bs)

        # create the field encoder and writer
        csv_encoder = StatusEncoder(recorder.info)
        listener = MultiplexListener(csv_encoder.encode)

    # if recorder file isn't specified, pretty print tweets to stdout
    else:
        listener = MultiplexListener(pprint_tweets)

    # capture tweets
    stream = Stream(auth, listener)
    try:
        if args.keywords and not args.locations:
            logger.info('starting stream filter track of %s', args.keywords)
            stream.filter(track=args.keywords.split(','))

        elif args.locations and not args.keywords:
            logger.info('starting stream filter location of %s', 
                        args.locations)
            stream.filter(locations=parse_locations(args.locations))

        elif args.keywords and args.locations:
            logger.info('starting stream filter track and location')
            stream.filter(target=args.keywords.split(','),
                          locations=parse_locations(args.locations))
        else:
            logger.info('starting stream sample')
            stream.sample()

    except Exception as e:
        logger.error('unable to establish connection', exc_info=True)
        sys.exit(1)


if __name__ == '__main__':
    main()
